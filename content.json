{"meta":{"title":"Hans的个人博客","subtitle":"技术型宅男","description":"珍惜每一天","author":"Hans Moore","url":"https://prohansm.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-08-08T08:20:30.000Z","updated":"2020-08-08T10:46:30.492Z","comments":true,"path":"about/index.html","permalink":"https://prohansm.github.io/about/index.html","excerpt":"","text":"Mo Hao I am a student in Hangzhou Dianzi Universty."},{"title":"分类","date":"2020-08-08T08:21:33.000Z","updated":"2020-08-08T10:46:39.682Z","comments":true,"path":"categories/index.html","permalink":"https://prohansm.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-08T08:21:06.000Z","updated":"2020-08-08T10:46:47.171Z","comments":true,"path":"tags/index.html","permalink":"https://prohansm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《利用Python进行数据分析》中的一些问题和解决方法","slug":"Data-Analysis-1","date":"2020-09-06T07:55:49.000Z","updated":"2020-09-14T05:31:07.989Z","comments":true,"path":"2020/09/06/Data-Analysis-1/","link":"","permalink":"https://prohansm.github.io/2020/09/06/Data-Analysis-1/","excerpt":"","text":"背景今天是9月6号，到了开学的日子啦。回到寝室以后，稍微整理了一下寝室以后就发现没有事情可以干了。于是乎，本着一月一更的精神和培养写博客的习惯我就来更新啦！正好在暑假里，我看了一本叫做《利用Python进行数据分析》的书。 在阅读的过程中，我发现书中有一部分知识随着时间的迁移而变得不再适用。所以在本文中我将列举一些我在读书过程中遇到的一些问题以及对应的解决办法，希望能够帮到正在阅读该书遇到困惑的同学。 注：本文中的解决方法也可能随着时间的迁移和版本的更新而失效，届时希望各位朋友能够自行探索解决方案。 问题1：matches.str报错问题描述在书第214页有这样的两段语句： 123matches.str.get(1)matches.str[0] 在执行完以后会出现这样一段提示： AttributeError: Can only use .str accessor with string values! 我认为在早期版本的pandas中对没有字符串值的Series使用 .str系列操作将会返回一个对应全部是NaN值的Series，而在当前版本的pandas中执行这一操作将直接报错。 解决方法data正好是由字符串值组成的Series，我们可以通过data来搞清楚这个两个操作背后的逻辑。 例如： 执行 1data.str.get(1) 将会返回 Dave aSteve tRob oWes NaNdtype: object 执行 1data.str[0] 将会返回 Dave dSteve sRob rWes NaNdtype: object 问题2：创建时间分组器失败问题描述在该书的360页有这样一段语句： 1time_key = pd.TimeGrouper(&#x27;5min&#x27;) 在执行完成后会返回这样一段提示： AttributeError: module ‘pandas’ has no attribute ‘TimeGrouper’ 这是因为在当前版本的pandas中TimeGrouper对象遭到弃用。 解决方法虽然无法通过TimeGrouper()函数创建时间分组器，但我们仍可以使用Grouper函数创建时间分组器。而且不同于TimeGrouper()函数创建的时间分组器只能对时间索引进行分组，Grouper函数创建的时间分组器对任意列上时间序列均可进行分组 只需要在Grouper()函数中传入列名和频率即可对对应列上的时间序列按指定指定的时间间隔进行分组，如果不传入列名只传入频率则按时间索引进行分组。 例如书本上语句可以改成： 1time_key &#x3D; pd.Grouper(freq&#x3D;&#39;5min&#39;) 再执行接下来的语句即可得到正确的结果。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://prohansm.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://prohansm.github.io/tags/Python/"},{"name":"数据分析","slug":"数据分析","permalink":"https://prohansm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"简单分析快速排序","slug":"quicksortanalysis","date":"2020-08-08T10:37:44.000Z","updated":"2020-08-08T16:29:12.491Z","comments":true,"path":"2020/08/08/quicksortanalysis/","link":"","permalink":"https://prohansm.github.io/2020/08/08/quicksortanalysis/","excerpt":"","text":"介绍快速排序可能是目前应用最广泛的排序算法，甚至被誉为20世纪科学和工程领域的十大算法之一。它实现简单，性能优异，被广泛应用于各类排序场景中。在一般情况下，它的时间复杂度为NlogN，空间复杂度为lgN。 原理计算机领域专家吴军博士曾经说过： 一个好的算法应该像AK-47冲锋枪那样：简单、有效、可靠性好、而且容易读懂。 快速排序就是一个这样的典型例子。尽管在工程实现上，为了适应具体的要求它可能会很复杂，但是在原理上快速排序是简单的。 它的原理是这样的：将一组待排序的数字打乱，从中选取一个数，改变它左右两边的数字，使得它左边的数字都小于它，它右边的数字都大于它，然后以这个数字为分界线，将这个组分为两个区域，不断重复上述操作，最终你将得到一个有序的数组。 对于学过数学归纳法的人来说上面的过程应该很好理解。如果你没有学过数学归纳法，有一个形象的比喻可以帮助你理解 ：在多米诺骨牌的游戏中有两件重要的事，推倒第一块骨牌和前一块骨牌倒下会带动后一块骨牌倒下。所以最后一块骨牌一定会倒下。 基本算法在实现基本算法之前，我们需要提出一个概念：切分。这个概念的提出，有助于我们理解快速排序。 切分：选取一个数，改变它左右两边的数字，使得它左边的数字都小于它，它右边的数字都大于它。 以下是其通过Java语言的实现版本： 1234567891011121314public static int partition(Comparable[] a,int lo, int hi)&#123; //将数组切分为a[lo..i-1],a[i],a[i+1..hi] int i = lo, j = hi + 1; //左右扫描指针 Comparable v = a[lo]; //切分元素,选数组的第一个元素能简化算法实现 while(true)&#123; //扫描左右，检查扫描是否结束并交换元素 while (less(a[++i],v)) if (i == hi) break; while (less(v,a[--j])) if (j == lo) break; if (i &gt;= j) break; exch(a, i, j); &#125; exch(a, lo, j); //将v放入正确的位置a[j]中 return j; //a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi] 达成,返回有序元素的索引&#125; 在这里我们给出操作数据所用的两个方法的具体内容： 123private static boolean less(Comparable v, Comparable w)&#123; return v.comparTo(w) &lt; 0;&#125; 123private static void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125; 切分是快速排序的核心。在切分的过程中我们总是能够排定一个元素，通过递归地调用切分，我们就实现了快速排序。 以下是快速排序通过Java语言实现的版本： 12345678910111213public class Quick&#123; public static void sort(Comparable[] a)&#123; StdRandom.shuffle(a); //消除对输入的依赖 sort(a, 0, a.length - 1); &#125;&#125;private static void sort(Comparable[] a, int lo, int hi)&#123; if(hi &lt;= lo) return; int j = partition(a, lo, hi); //切分 sort(a, lo, j-1); //将左半部分排序 sort(a, j+1, hi); //将右半部分排序&#125; 下图展示的是一个需要3层切分的数组快速排序的过程： 在制作上图之前，我希望通过颜色的标注，让读者能够清楚地理解快速排序过程中的顺序问题。但是在制造完上图之后，我发现颜色的标注也并不能清楚地说明该问题。有钻研精神的读者可以借助上图仔细思考一番，或者自行画图跟踪理解。 性能特点时间复杂度：NlogN 空间复杂度：lgN 将长度为N的无重复数组排序，快速排序平均需要~2NlnN次比较（以及1/6的交换）。 快速排序最多需要约(N^2)/2次比较，但随机打乱数组能够预防这种情况。 改进标准的快速排序算法已经十分优秀了，但是这还不是它的极限，我们还有很多种方法让它变得更加优秀。 下面介绍其中的一种方法：三向切分。对于存在大量重复元素的数组，这种方法比标准的快速排序的效率高得多。但对于重复元素不多数组，这种方法反而比标准的快速排序效率低。 以下是三向切分的快速排序通过Java语言实现的版本： 1234567891011121314151617181920public class Quick3way&#123; public static void sort(Comparable[] a)&#123; StdRandom.shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i &lt;= gt)&#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; sort(a, lo, lt - 1); sort(a, gt + 1, hi); &#125;&#125; 这段排序代码的切分能够将和切分元素相等的元素归位，这样它们就不会被包含在递归调用处理的子数组之中了，从而减少了元素交换的次数。但在重复元素不多的情况下，它比标准的快速排序多使用了很多次交换。 缺点快速排序存在着诸多显而易见的优点，那么它是一个完美的算法吗？可惜不是这样的。它也存在着缺点：它会交换相同元素。 可能有的人会问了，这为什么会成为缺点呢？ 那是因为在实际应用排序的过程中，我们往往需要针对多组关键字进行排序，交换相同元素会使得一个关键字有序的过程中，另一个关键字无序。 比如，某中学的学生系统原先按照学生姓名进行排序，现在要按照成绩高低进行排名，成绩相同时按照姓名排名，使用快速排序会导致成绩相同时姓名是无序的。 总结快速排序是一种经典、优雅、高效的排序算法。它有着许多优点，但它并不是完美的，它也存在着缺点。 参考文献《算法（第4版）》 本文中的代码部分均来自《算法（第4版）》。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://prohansm.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://prohansm.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://prohansm.github.io/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-08T03:58:47.031Z","updated":"2020-08-08T03:58:47.031Z","comments":true,"path":"2020/08/08/hello-world/","link":"","permalink":"https://prohansm.github.io/2020/08/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://prohansm.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://prohansm.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://prohansm.github.io/tags/Python/"},{"name":"数据分析","slug":"数据分析","permalink":"https://prohansm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"算法","slug":"算法","permalink":"https://prohansm.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://prohansm.github.io/tags/Java/"}]}